generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

enum UserRole {
  HOST
  ATTENDEE
  BOTH // Users can be both hosts and attendees
}

enum KYCStatus {
  NOT_REQUIRED
  PENDING
  SUBMITTED
  APPROVED
  REJECTED
}

enum PaymentMethodType {
  CARD
  BANK_ACCOUNT
  DIGITAL_WALLET
}

enum InteractionType {
  VIEW
  CLICK
  SHARE
  BOOKMARK
  RSVP
  PURCHASE
  OTHER
}

model User {
  id                    String    @id @default(cuid())
  
  firstName             String    @map("first_name")
  lastName              String    @map("last_name")
  email                 String    @unique
  emailVerified         Boolean   @default(false) @map("email_verified")
  phoneNumber           String    @map("phone_number")
  phoneVerified         Boolean   @default(false) @map("phone_verified")
  password              String    
  
  // Role Management
  role                  UserRole  @default(ATTENDEE)
  
  // Optional Basic Fields
  profilePictureUrl     String?   @map("profile_picture_url")
  
  // Host-Specific Fields
  organizationName      String?   @map("organization_name")
  address               String?   // Store as JSON string for structured address
  kycStatus             KYCStatus @default(NOT_REQUIRED) @map("kyc_status")
  kycDocuments          Json?     @map("kyc_documents") // Store document URLs/IDs
  payoutDetails         Json?     @map("payout_details") // Stripe Connect ID or bank details
  
  // Attendee-Specific Fields
  savedPaymentMethods   PaymentMethod[]
  
  // Preferences & Metadata (Optional for both)
  preferences           Json?     // Store genres, locations as JSON
  deviceTokens          String[]  @map("device_tokens") // For push notifications
  language              String?   @default("en")
  timezone              String?   @default("UTC")
  
  // Timestamps
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  lastLogin             DateTime? @map("last_login")
  
  // Relations
  hostedEvents          Event[]   @relation("HostedEvents")
  bookings              Booking[]
  reviews               Review[]
  
  @@map("users")
}

model PaymentMethod {
  id                    String              @id @default(cuid())
  userId                String              @map("user_id")
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type                  PaymentMethodType
  token                 String              // Stripe payment method ID or similar
  last4                 String?             // Last 4 digits for display
  brand                 String?             // Card brand (Visa, Mastercard, etc.)
  expiryMonth           Int?                @map("expiry_month")
  expiryYear            Int?                @map("expiry_year")
  
  isDefault             Boolean             @default(false) @map("is_default")
  
  createdAt             DateTime            @default(now()) @map("created_at")
  updatedAt             DateTime            @updatedAt @map("updated_at")
  
  @@index([userId])
  @@map("payment_methods")
}

// Example Event model (for context)
model Event {
  id                    String    @id @default(cuid())
  hostId                String    @map("host_id")
  host                  User      @relation("HostedEvents", fields: [hostId], references: [id], onDelete: Cascade)
  
  title                 String
  description           String    @db.Text
  
  // Add your event fields here
  
  bookings              Booking[]
  reviews               Review[]
  
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  
  @@index([hostId])
  @@map("events")
}

// Example Booking model (for context)
model Booking {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId               String    @map("event_id")
  event                 Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Add your booking fields here
  
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  
  @@index([userId])
  @@index([eventId])
  @@map("bookings")
}

// Example Review model (for context)
model Review {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId               String    @map("event_id")
  event                 Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  rating                Int       // 1-5 stars
  comment               String?   @db.Text
  
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  
  @@index([userId])
  @@index([eventId])
  @@map("reviews")
}



// Track all user interactions for recommendation engine
model UserInteraction {
  id                    String          @id @default(cuid())
  userId                String          @map("user_id")
  user                  User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId               String          @map("event_id")
  event                 Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Interaction Details
  interactionType       InteractionType @map("interaction_type")
  sessionId             String?         @map("session_id") // Group interactions by session
  
  // Context
  source                String?         // homepage, search, category_page, etc.
  deviceType            String?         @map("device_type") // mobile, desktop, tablet
  
  // Metrics
  durationSeconds       Int?            @map("duration_seconds") // Time spent viewing
  scrollDepth           Int?            @map("scroll_depth") // Percentage scrolled
  
  createdAt             DateTime        @default(now()) @map("created_at")
  
  @@index([userId, createdAt])
  @@index([eventId, interactionType])
  @@index([sessionId])
  @@map("user_interactions")
}

// User favorites/wishlist
model Favorite {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId               String    @map("event_id")
  event                 Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime  @default(now()) @map("created_at")
  
  @@unique([userId, eventId])
  @@index([userId])
  @@map("favorites")
}

// Search history for understanding user intent
model SearchHistory {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  query                 String
  filters               Json?     // Category, location, price range filters used
  resultsCount          Int       @map("results_count")
  clickedEventId        String?   @map("clicked_event_id") // Which result was clicked
  
  createdAt             DateTime  @default(now()) @map("created_at")
  
  @@index([userId, createdAt])
  @@map("search_history")
}

// ============================================
// RECOMMENDATION SCORES (Computed/Cached)
// ============================================

// Store computed recommendation scores for faster queries
model UserEventScore {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  eventId               String    @map("event_id")
  
  // Composite score (0-100)
  score                 Float
  
  // Individual score components
  collaborativeScore    Float?    @map("collaborative_score") // Based on similar users
  contentScore          Float?    @map("content_score")       // Based on event attributes
  popularityScore       Float?    @map("popularity_score")    // Based on trending
  recencyScore          Float?    @map("recency_score")       // Based on event date
  
  // Metadata
  computedAt            DateTime  @map("computed_at")
  
  @@unique([userId, eventId])
  @@index([userId, score])
  @@index([computedAt]) // For refreshing old scores
  @@map("user_event_scores")
}